op memory = CPYFP | CPYFPN | CPYFPRN | CPYFPRT | CPYFPRTN | CPYFPRTRN | CPYFPRTWN |
    CPYFPT | CPYFPTN | CPYFPTRN | CPYFPTWN | CPYFPWN | CPYFPWT | CPYFPWTN | CPYFPWTRN | CPYFPWTWN |
    CPYP | CPYPN | CPYPRN | CPYPRT | CPYPRTN | CPYPRTRN | CPYPRTWN | 
    CPYPT | CPYPTN | CPYPTRN | CPYPTWN | CPYPWN | CPYPWT | CPYPWTRN | CPYPWTWN |
    CSDB | DGH | DMB | DSB | loads | loads_atomic

macro getCPYFPVariant(op1) = \
    if op1 == 2 then \
        "cpyfe" \
    else if op1 == 1 then \
            "cpyfm" \
        else if op1 == 0 then \
                "cpyfp" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFP(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b0 1 1 0 0 1%2b0%s0 0 0 0 0 1%s%s", sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
        // if !HaveFeatMOPS() then UNDEFINED;
        // if sz != '00' then UNDEFINED;
        // integer d = UInt(Rd);
        // integer s = UInt(Rs);
        // integer n = UInt(Rn);
        // bits(4) options = op2;
        // MOPSStage stage;
        // case op1 of
        // when '00' stage = MOPSStage_Prologue;
        // when '01' stage = MOPSStage_Main;
        // when '10' stage = MOPSStage_Epilogue;
        // otherwise SEE "Memory Copy and Memory Set";
        // CheckMOPSEnabled();
        // if s == n || s == d || n == d || d == 31 || s == 31 || n == 31 then
        // c = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        // assert c IN {Constraint_UNDEF, Constraint_NOP};
        // case c of
        // when Constraint_UNDEF UNDEFINED;
        // when Constraint_NOP
        // EndOfInstruction();
        // integer N = MaxBlockSizeCopiedBytes();
        // bits(64) toaddress = X[d, 64];
        // bits(64) fromaddress = X[s, 64];
        // bits(64) cpysize = X[n, 64];
        // bits(4) nzcv = PSTATE.<N,Z,C,V>;
        // bits(64) stagecpysize;
        // bits(8*N) readdata;
        // integer B;
        // boolean supports_option_a = CPYFOptionA();
        // boolean rprivileged;
        // boolean wprivileged;
        // case PSTATE.EL of
        // when EL0
        // rprivileged = FALSE;
        // wprivileged = FALSE;
        // when EL1
        // if EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11' then
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // else
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // when EL2
        // if HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11' then
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // else
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // when EL3
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // if HaveUAOExt() && PSTATE.UAO == '1' then
        // rprivileged = PSTATE.EL != EL0;
        // wprivileged = PSTATE.EL != EL0;
        // boolean rnontemporal = options<3> == '1';
        // boolean wnontemporal = options<2> == '1';
        // AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
        // AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
        // if stage == MOPSStage_Prologue then
        // if cpysize<63> == '1' then cpysize = 0x7FFFFFFFFFFFFFFF<63:0>;
        // if supports_option_a then
        // nzcv = '0000';
        // // Copy in the forward direction offsets the arguments.
        // toaddress = toaddress + cpysize;
        // fromaddress = fromaddress + cpysize;
        // cpysize = Zeros(64) - cpysize;
        // else
        // nzcv = '0010';
        // // IMP DEF selection of the amount covered by pre-processing.
        // stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        // assert stagecpysize<63> == cpysize<63> || stagecpysize == Zeros(64);
        // if SInt(cpysize) > 0 then
        // assert SInt(stagecpysize) <= SInt(cpysize);
        // else
        // assert SInt(stagecpysize) >= SInt(cpysize);
        // else
        // boolean zero_size_exceptions = MemCpyZeroSizeCheck();
        // // Check if this version is consistent with the state of the call.
        // if zero_size_exceptions || SInt(cpysize) != 0 then
        // if supports_option_a then
        // if nzcv<1> == '1' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,options);
        // else
        // if nzcv<1> == '0' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,
        // options);
        // bits(64) postsize = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        // assert postsize<63> == cpysize<63> || SInt(postsize) == 0;
        // if stage == MOPSStage_Main then
        // stagecpysize = cpysize - postsize;
        // // Check if the parameters to this instruction are valid.
        // if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = FALSE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // else
        // stagecpysize = postsize;
        // // Check if the parameters to this instruction are valid for the epilogue.
        // if (cpysize != postsize || MemCpyParametersIllformedE(toaddress, fromaddress, cpysize)) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = TRUE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // if supports_option_a then
        // while SInt(stagecpysize) != 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= -1 * SInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress+cpysize, B, raccdesc];
        // Mem[toaddress+cpysize, B, waccdesc] = readdata<B*8-1:0>;
        // cpysize = cpysize + B;
        // stagecpysize = stagecpysize + B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // else
        // while UInt(stagecpysize) > 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= UInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress, B, raccdesc];
        // Mem[toaddress, B, waccdesc] = readdata<B*8-1:0>;
        // fromaddress = fromaddress + B;
        // toaddress = toaddress + B;
        // cpysize = cpysize - B;
        // stagecpysize = stagecpysize - B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // if stage == MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // PSTATE.<N,Z,C,V> = nzcv;
    }

macro getCPYFPNVariant(op1) = \
    if op1 == 2 then \
        "cpyfen" \
    else if op1 == 1 then \
            "cpyfmn" \
        else if op1 == 0 then \
                "cpyfpn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!,[%s]!,%s!", getCPYFPNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b0 1 1 0 0 1%2b0%s1 1 0 0 0 1%s%s", sz, op1, Rs.image, Rn.image, Rd.image)
    action = {
        // if !HaveFeatMOPS() then UNDEFINED;
        // if sz != '00' then UNDEFINED;
        // integer d = UInt(Rd);
        // integer s = UInt(Rs);
        // integer n = UInt(Rn);
        // bits(4) options = op2;
        // MOPSStage stage;
        // case op1 of
        // when '00' stage = MOPSStage_Prologue;
        // when '01' stage = MOPSStage_Main;
        // when '10' stage = MOPSStage_Epilogue;
        // otherwise SEE "Memory Copy and Memory Set";
        // CheckMOPSEnabled();
        // if s == n || s == d || n == d || d == 31 || s == 31 || n == 31 then
        // c = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        // assert c IN {Constraint_UNDEF, Constraint_NOP};
        // case c of
        // when Constraint_UNDEF UNDEFINED;
        // when Constraint_NOP
        // EndOfInstruction();
        // integer N = MaxBlockSizeCopiedBytes();
        // bits(64) toaddress = X[d, 64];
        // bits(64) fromaddress = X[s, 64];
        // bits(64) cpysize = X[n, 64];
        // bits(4) nzcv = PSTATE.<N,Z,C,V>;
        // bits(64) stagecpysize;

        // bits(8*N) readdata;
        // integer B;
        // boolean supports_option_a = CPYFOptionA();
        // boolean rprivileged;
        // boolean wprivileged;
        // case PSTATE.EL of
        // when EL0
        // rprivileged = FALSE;
        // wprivileged = FALSE;
        // when EL1
        // if EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11' then
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // else
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // when EL2
        // if HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11' then
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // else
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // when EL3
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // if HaveUAOExt() && PSTATE.UAO == '1' then
        // rprivileged = PSTATE.EL != EL0;
        // wprivileged = PSTATE.EL != EL0;
        // boolean rnontemporal = options<3> == '1';
        // boolean wnontemporal = options<2> == '1';
        // AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
        // AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
        // if stage == MOPSStage_Prologue then
        // if cpysize<63> == '1' then cpysize = 0x7FFFFFFFFFFFFFFF<63:0>;
        // if supports_option_a then
        // nzcv = '0000';
        // // Copy in the forward direction offsets the arguments.
        // toaddress = toaddress + cpysize;
        // fromaddress = fromaddress + cpysize;
        // cpysize = Zeros(64) - cpysize;
        // else
        // nzcv = '0010';
        // // IMP DEF selection of the amount covered by pre-processing.
        // stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        // assert stagecpysize<63> == cpysize<63> || stagecpysize == Zeros(64);
        // if SInt(cpysize) > 0 then
        // assert SInt(stagecpysize) <= SInt(cpysize);
        // else
        // assert SInt(stagecpysize) >= SInt(cpysize);
        // else
        // boolean zero_size_exceptions = MemCpyZeroSizeCheck();
        // // Check if this version is consistent with the state of the call.
        // if zero_size_exceptions || SInt(cpysize) != 0 then
        // if supports_option_a then
        // if nzcv<1> == '1' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,options);
        // else
        // if nzcv<1> == '0' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,
        // options);
        // bits(64) postsize = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        // assert postsize<63> == cpysize<63> || SInt(postsize) == 0;
        // if stage == MOPSStage_Main then
        // stagecpysize = cpysize - postsize;
        // // Check if the parameters to this instruction are valid.
        // if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = FALSE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // else
        // stagecpysize = postsize;
        // // Check if the parameters to this instruction are valid for the epilogue.
        // if (cpysize != postsize || MemCpyParametersIllformedE(toaddress, fromaddress, cpysize)) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = TRUE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // if supports_option_a then
        // while SInt(stagecpysize) != 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= -1 * SInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress+cpysize, B, raccdesc];
        // Mem[toaddress+cpysize, B, waccdesc] = readdata<B*8-1:0>;
        // cpysize = cpysize + B;
        // stagecpysize = stagecpysize + B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // else
        // while UInt(stagecpysize) > 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= UInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress, B, raccdesc];
        // Mem[toaddress, B, waccdesc] = readdata<B*8-1:0>;
        // fromaddress = fromaddress + B;
        // toaddress = toaddress + B;
        // cpysize = cpysize - B;
        // stagecpysize = stagecpysize - B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // if stage == MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // PSTATE.<N,Z,C,V> = nzcv;
    }

macro getCPYFPRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfern" \
    else if op1 == 1 then \
            "cpyfmrn" \
        else if op1 == 0 then \
                "cpyfprn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b0 1 1 0 0 1%2b 0 %s 1 0 0 0 0 1 %s%s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
        // if !HaveFeatMOPS() then UNDEFINED;
        // if sz != '00' then UNDEFINED;
        // integer d = UInt(Rd);
        // integer s = UInt(Rs);
        // integer n = UInt(Rn);
        // bits(4) options = op2;
        // MOPSStage stage;
        // case op1 of
        // when '00' stage = MOPSStage_Prologue;
        // when '01' stage = MOPSStage_Main;
        // when '10' stage = MOPSStage_Epilogue;
        // otherwise SEE "Memory Copy and Memory Set";
        // CheckMOPSEnabled();
        // if s == n || s == d || n == d || d == 31 || s == 31 || n == 31 then
        // c = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        // assert c IN {Constraint_UNDEF, Constraint_NOP};
        // case c of
        // when Constraint_UNDEF UNDEFINED;
        // when Constraint_NOP
        // EndOfInstruction();
        // integer N = MaxBlockSizeCopiedBytes();
        // bits(64) toaddress = X[d, 64];
        // bits(64) fromaddress = X[s, 64];
        // bits(64) cpysize = X[n, 64];
        // bits(4) nzcv = PSTATE.<N,Z,C,V>;
        // bits(64) stagecpysize;

        // bits(8*N) readdata;
        // integer B;
        // boolean supports_option_a = CPYFOptionA();
        // boolean rprivileged;
        // boolean wprivileged;
        // case PSTATE.EL of
        // when EL0
        // rprivileged = FALSE;
        // wprivileged = FALSE;
        // when EL1
        // if EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11' then
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // else
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // when EL2
        // if HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11' then
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // else
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // when EL3
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // if HaveUAOExt() && PSTATE.UAO == '1' then
        // rprivileged = PSTATE.EL != EL0;
        // wprivileged = PSTATE.EL != EL0;
        // boolean rnontemporal = options<3> == '1';
        // boolean wnontemporal = options<2> == '1';
        // AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
        // AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
        // if stage == MOPSStage_Prologue then
        // if cpysize<63> == '1' then cpysize = 0x7FFFFFFFFFFFFFFF<63:0>;
        // if supports_option_a then
        // nzcv = '0000';
        // // Copy in the forward direction offsets the arguments.
        // toaddress = toaddress + cpysize;
        // fromaddress = fromaddress + cpysize;
        // cpysize = Zeros(64) - cpysize;
        // else
        // nzcv = '0010';
        // // IMP DEF selection of the amount covered by pre-processing.
        // stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        // assert stagecpysize<63> == cpysize<63> || stagecpysize == Zeros(64);
        // if SInt(cpysize) > 0 then
        // assert SInt(stagecpysize) <= SInt(cpysize);
        // else
        // assert SInt(stagecpysize) >= SInt(cpysize);
        // else
        // boolean zero_size_exceptions = MemCpyZeroSizeCheck();
        // // Check if this version is consistent with the state of the call.
        // if zero_size_exceptions || SInt(cpysize) != 0 then
        // if supports_option_a then
        // if nzcv<1> == '1' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,options);
        // else
        // if nzcv<1> == '0' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,
        // options);
        // bits(64) postsize = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        // assert postsize<63> == cpysize<63> || SInt(postsize) == 0;
        // if stage == MOPSStage_Main then
        // stagecpysize = cpysize - postsize;
        // // Check if the parameters to this instruction are valid.
        // if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = FALSE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // else
        // stagecpysize = postsize;
        // // Check if the parameters to this instruction are valid for the epilogue.
        // if (cpysize != postsize || MemCpyParametersIllformedE(toaddress, fromaddress, cpysize)) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = TRUE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // if supports_option_a then
        // while SInt(stagecpysize) != 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= -1 * SInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress+cpysize, B, raccdesc];
        // Mem[toaddress+cpysize, B, waccdesc] = readdata<B*8-1:0>;
        // cpysize = cpysize + B;
        // stagecpysize = stagecpysize + B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // else
        // while UInt(stagecpysize) > 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= UInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress, B, raccdesc];
        // Mem[toaddress, B, waccdesc] = readdata<B*8-1:0>;
        // fromaddress = fromaddress + B;
        // toaddress = toaddress + B;
        // cpysize = cpysize - B;
        // stagecpysize = stagecpysize - B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // if stage == MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // PSTATE.<N,Z,C,V> = nzcv;
    }

macro getCPYFPRTVariant(op1) = \
    if op1 == 2 then \
        "cpyfert" \
    else if op1 == 1 then \
            "cpyfmrt" \
        else if op1 == 0 then \
                "cpyfprt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPRTNVariant(op1) = \
    if op1 == 2 then \
        "cpyfertn" \
    else if op1 == 1 then \
            "cpyfmrtn" \
        else if op1 == 0 then \
                "cpyfprtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPRTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfertrn" \
    else if op1 == 1 then \
            "cpyfmrtrn" \
        else if op1 == 0 then \
                "cpyfprtrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPRTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfertwn" \
    else if op1 == 1 then \
            "cpyfmrtwn" \
        else if op1 == 0 then \
                "cpyfprtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTVariant(op1) = \
    if op1 == 2 then \
        "cpyfet" \
    else if op1 == 1 then \
            "cpyfmt" \
        else if op1 == 0 then \
                "cpyfpt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTNVariant(op1) = \
    if op1 == 2 then \
        "cpyfetn" \
    else if op1 == 1 then \
            "cpyfmtn" \
        else if op1 == 0 then \
                "cpyfptn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfetrn" \
    else if op1 == 1 then \
            "cpyfmtrn" \
        else if op1 == 0 then \
                "cpyfptrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfetwn" \
    else if op1 == 1 then \
            "cpyfmtwn" \
        else if op1 == 0 then \
                "cpyfptwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewn" \
    else if op1 == 1 then \
            "cpyfmwn" \
        else if op1 == 0 then \
                "cpyfpwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTVariant(op1) = \
    if op1 == 2 then \
        "cpyfewt" \
    else if op1 == 1 then \
            "cpyfmwt" \
        else if op1 == 0 then \
                "cpyfpwt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 0 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewtn" \
    else if op1 == 1 then \
            "cpyfmwtn" \
        else if op1 == 0 then \
                "cpyfpwtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewtn" \
    else if op1 == 1 then \
            "cpyfmwtn" \
        else if op1 == 0 then \
                "cpyfpwtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 0 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewtwn" \
    else if op1 == 1 then \
            "cpyfmwtwn" \
        else if op1 == 0 then \
                "cpyfpwtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPVariant(op1) = \
    if op1 == 2 then \
        "cpye" \
    else if op1 == 1 then \
            "cpym" \
        else if op1 == 0 then \
                "cpyp" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYP(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPNVariant(op1) = \
    if op1 == 2 then \
        "cpyen" \
    else if op1 == 1 then \
            "cpymn" \
        else if op1 == 0 then \
                "cpypn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRNVariant(op1) = \
    if op1 == 2 then \
        "cpyern" \
    else if op1 == 1 then \
            "cpymrn" \
        else if op1 == 0 then \
                "cpyprn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 0 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTVariant(op1) = \
    if op1 == 2 then \
        "cpyert" \
    else if op1 == 1 then \
            "cpymrt" \
        else if op1 == 0 then \
                "cpyprt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTNVariant(op1) = \
    if op1 == 2 then \
        "cpyertn" \
    else if op1 == 1 then \
            "cpymrtn" \
        else if op1 == 0 then \
                "cpyprtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyertrn" \
    else if op1 == 1 then \
            "cpymrtrn" \
        else if op1 == 0 then \
                "cpyprtrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyertwn" \
    else if op1 == 1 then \
            "cpymrtwn" \
        else if op1 == 0 then \
                "cpyprtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTVariant(op1) = \
    if op1 == 2 then \
        "cpyet" \
    else if op1 == 1 then \
            "cpymt" \
        else if op1 == 0 then \
                "cpypt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTNVariant(op1) = \
    if op1 == 2 then \
        "cpyetn" \
    else if op1 == 1 then \
            "cpymtn" \
        else if op1 == 0 then \
                "cpyptn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyetrn" \
    else if op1 == 1 then \
            "cpymtrn" \
        else if op1 == 0 then \
                "cpyptrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyetwn" \
    else if op1 == 1 then \
            "cpymtwn" \
        else if op1 == 0 then \
                "cpyptwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWNVariant(op1) = \
    if op1 == 2 then \
        "cpyewn" \
    else if op1 == 1 then \
            "cpymwn" \
        else if op1 == 0 then \
                "cpypwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTVariant(op1) = \
    if op1 == 2 then \
        "cpyewt" \
    else if op1 == 1 then \
            "cpymwt" \
        else if op1 == 0 then \
                "cpypwt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTNVariant(op1) = \
    if op1 == 2 then \
        "cpyewtn" \
    else if op1 == 1 then \
            "cpymwtn" \
        else if op1 == 0 then \
                "cpypwtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyewtrn" \
    else if op1 == 1 then \
            "cpymwtrn" \
        else if op1 == 0 then \
                "cpypwtrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyewtwn" \
    else if op1 == 1 then \
            "cpymwtwn" \
        else if op1 == 0 then \
                "cpypwtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

op CSDB()
    syntax = "csdb"
    image = "1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 1 0 0 1 1 1 1 1"
    action = {
        //ConsumptionOfSpeculativeDataBarrier();
    }

op DGH()
    syntax = "dgh"
    image = "1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1"
    action = {
    }

op DMB(CRm:u4)
    syntax = format("dmb  #%d", CRm)
    image = format("1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 %4b 1 0 1 1 1 1 1 1", CRm)
    action = {
    }

op DSB(CRm:u4)
    syntax = format("dsb  #%d", CRm)
    image = format("1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 %4b 1 0 0 1 1 1 1 1", CRm)
    action = {
    }

op ISB(CRm:u4)
    syntax = format("isb  #%d", CRm)
    image = format("1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 %4b 1 1 0 1 1 1 1 1", CRm)
    action = {
    }

op loads = LD64B | LDADDB | LDADDH | LDADD | LDAPR | LDAPRB | LDAPRH | LDAPUR | LDAPURB | LDAPURH | LDAPURSB | LDAPURSH | LDAPURSW |
    LDAR | LDARB | LDARH | LDAXP | LDAXR | LDAXRB | LDAXRH | LDCLRB | LDCLRH | LDCLR | LDEORB | LDEORH | LDEOR | LDG | LDGM | LDLARB | LDLARH | LDLAR  | LDNP | LDP_postindex | LDP_preindex | LDP_signedoffset | LDPSW_postindex | LDPSW_preindex | LDPSW_signedoffset |  LDR_immediate_postindex | LDR_immediate_preindex | LDR_immediate_unsignedoffset | LDR_literal | LDR_register | LDRAA | LDRAB | LDRB_immediate_postindex | LDRB_immediate_preindex | LDRB_immediate_unsignedoffset | LDRB_register | LDRH_immediate_postindex | LDRH_immediate_preindex | LDRH_immediate_unsignedoffset | LDRH_register | LDRSB_immediate_postindex | LDRSB_immediate_preindex | LDRSB_immediate_unsignedoffset | LDRSB_register | LDRSH_immediate_postindex | LDRSH_immediate_preindex | LDRSH_immediate_unsignedoffset | LDRSH_register | LDRSW_immediate_postindex | LDRSW_immediate_preindex | LDRSW_immediate_unsignedoffset | LDRSW_literal | LDRSW_register | LDTR | LDTRB | LDTRH | LDTRSB | LDTRSH | LDTRSW | LDUR | LDURB | LDURH | LDURSB | LDURSH | LDURSW | LDXP | LDXR | LDXRB | LDXRH

op LD64B(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ld64b %s, [%s]", get64Reg(Rt), get64RegoSP(Rn))
    image = format("1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 0 %s%s", Rn.image, Rt.image)
    action = {
    }

macro getLDADDBVariante(A,R) = \
    if A == 1 && R == 0 then \
        "ldaddab" \
    else if A == 1 && R == 1 then \
        "ldaddalb" \
    else if A == 0 && R == 0 then \
        "ldaddb" \
    else if A == 0 && R == 1 then \
        "ldaddlb" \
    else "undefined lda??" \
    endif \
    endif \
    endif \
    endif

op LDADDB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDADDBVariante(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 0 0 0 %s%s", A,R,Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDADDHVariante(A,R) = \
    if A == 1 && R == 0 then \
        "ldaddah" \
    else if A == 1 && R == 1 then \
        "ldaddalh" \
    else if A == 0 && R == 0 then \
        "ldaddhh" \
    else if A == 0 && R == 1 then \
        "ldaddlh" \
    else "undefined lda??" \
    endif \
    endif \
    endif \
    endif

op LDADDH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDADDHVariante(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 0 0 0 %s%s", A,R,Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDADDVariante(A,R) = \
    if A == 0 && R == 0 then \
        "ldadd" \
    else if A == 1 && R == 0 then \
        "ldadda" \
    else if A == 1 && R == 1 then \
        "ldaddal" \
    else if A == 0 && R == 1 then \
        "ldaddl" \
    else "undefined lda??" \
    endif \
    endif \
    endif \
    endif

op LDADD(sf:u1, A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDADDVariante(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 0 0 0 %s%s", sf, A,R,Rs.image, Rn.image, Rt.image)
    action = {
    }

op LDAPR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapr %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDAPRB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaprb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDAPRH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaprh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDAPUR(sf:u1, imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapur %s, [%s, #%d]", get32o64Reg(sf,Rt), get64RegoSP(Rn), imm9)
    image = format("1 %1b 0 1 1 0 0 1 0 1 0 %9b 00 %s%s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURB(imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapurb %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 0 1 1 0 0 1 0 1 0 %9b 0 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURH(imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapurh %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 0 1 1 0 0 1 0 1 0 %9b 00 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURSB(opc:u1, imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapursb %s, [%s, #%d]", get32o64Reg(opc==0, Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 0 1 1 0 0 1 1 %1b 0 %9b 00 %s%s", opc, imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURSH(opc:u1, imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapursh %s, [%s, #%d]", get32o64Reg(opc==0,Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 0 1 1 0 0 1 1 %1b 0 %9b 00 %s%s", opc, imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURSW(imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapursw %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("1 0 0 1 1 0 0 1 1 0 0 %9b 00 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDAR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldar %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 1 1 1 1 1 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDARB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldarb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 11 1 1 1 %s%s", Rn.image, Rt.image)
    action = {
    }


op LDARH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldarh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 11 1 1 1%s%s", Rn.image, Rt.image)
    action = {
    }

op LDAXP(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX, Rt2:REG_INDEX)
    syntax = format("ldaxp %s, %s, [%s]", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 0 1 11 1 1 1 1 1 %s%s%s", sf, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDAXR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaxr %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDAXRB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaxrb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 0 0 1 0 0 0 0 1 0 1 1 11 1 1 1 1 1 1 1%s%s", Rn.image, Rt.image)
    action = {
    }

op LDAXRH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaxrh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 0 0 1 0 0 0 0 1 0 1 1 11 1 1 1 1 1 1 1%s%s", Rn.image, Rt.image)
    action = {
    }

macro getLDCLRBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldclrab" \
    else if A == 1 && R == 1 then \
        "ldclralb" \
    else if A == 0 && R == 0 then \
        "ldclrb" \
    else if A == 0 && R == 1 then \
        "ldclrlb" \
    else "undefined ldcl??" \
    endif endif endif endif

op LDCLRB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDCLRBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDCLRHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldclrah" \
    else if A == 1 && R == 1 then \
        "ldclralh" \
    else if A == 0 && R == 0 then \
        "ldclrh" \
    else if A == 0 && R == 1 then \
        "ldclrlh" \
    else "undefined ldcl??" \
    endif endif endif endif

op LDCLRH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDCLRHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDCLRVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldclra" \
    else if A == 1 && R == 1 then \
        "ldclral" \
    else if A == 0 && R == 0 then \
        "ldclr" \
    else if A == 0 && R == 1 then \
        "ldclrl" \
    else "undefined ldcl??" \
    endif endif endif endif

op LDCLR(sf:u1, A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDCLRVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf, Rt), get64RegoSP(Rt))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 1 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }


macro getLDEORBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldeorab" \
    else if A == 1 && R == 1 then \
        "ldeoralb" \
    else if A == 0 && R == 0 then \
        "ldeorb" \
    else if A == 0 && R == 1 then \
        "ldeorlb" \
    else "undefined ldeor??" \
    endif endif endif endif

op LDEORB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDEORBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDEORHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldeorah" \
    else if A == 1 && R == 1 then \
        "ldeoralh" \
    else if A == 0 && R == 0 then \
        "ldeorh" \
    else if A == 0 && R == 1 then \
        "ldeorlh" \
    else "undefined ldeor??" \
    endif endif endif endif

op LDEORH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDEORHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDEORVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldeora" \
    else if A == 1 && R == 1 then \
        "ldeoral" \
    else if A == 0 && R == 0 then \
        "ldeor" \
    else if A == 0 && R == 1 then \
        "ldeorl" \
    else "undefined ldeor??" \
    endif endif endif endif

op LDEOR(sf:u1, A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDEORVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf, Rt), get64RegoSP(Rt))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 0 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

op LDG(imm9:u9, Xn:REG_INDEX, Xt:REG_INDEX)
    syntax = format("ldg %s, [%s,#%d]", get64Reg(Xt), get64RegoSP(Xn), imm9)
    image = format("1 1 0 1 1 0 0 1 0 1 1 %9b 00 %s%s", imm9, Xn.image, Xt.image)
    action = {
    }

op LDGM(Xn:REG_INDEX, Xt:REG_INDEX)
    syntax = format("ldgm %s, [%s]", get64Reg(Xt), get64RegoSP(Xn))
    image = format("1 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 %s%s", Xn.image, Xt.image)
    action = {
    }

op LDLARB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldlarb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 1 1 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDLARH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldlarh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 0 0 1 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 1 1 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDLAR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldlar %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 1 1 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDNP(sf:u1, imm7:u7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldnp %s, %s, [%s,#%d]", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn), imm7)
    image = format("%1b 0 1 0 1 0 0 0 0 1 %7b %s %s %s", sf, imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDP_postindex(sf:u1, imm7:u7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldp %s, %s, [%s,#%d]", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn), imm7)
    image = format("%1b 0 1 0 1 0 0 0 1 1 %7b %s %s %s", sf, imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDP_preindex(sf:u1, imm7:u7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldp %s, %s, [%s,#%d]!", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn), imm7)
    image = format("%1b 0 1 0 1 0 0 1 1 1 %7b %s %s %s", sf, imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }
    
op LDP_signedoffset(sf:u1, imm7:s7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldp %s, %s, [%s,#%d]", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn), imm7)
    image = format("%1b 0 1 0 1 0 0 1 0 1 %7b %s %s %s", sf, imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDPSW_postindex(imm7:u7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldpsw %s, %s, [%s], #%d", get64Reg(Rt), get64Reg(Rt2), get64RegoSP(Rn), imm7)
    image = format(" 0 1 1 0 1 0 0 0 1 1 %7b %s %s %s", imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDPSW_preindex(imm7:u7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldpsw %s, %s, [%s, #%d]!", get64Reg(Rt), get64Reg(Rt2), get64RegoSP(Rn), imm7)
    image = format(" 0 1 1 0 1 0 0 1 1 1 %7b %s %s %s", imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDPSW_signedoffset(imm7:s7, Rt2:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldpsw %s, %s, [%s, #%d]", get64Reg(Rt), get64Reg(Rt2), get64RegoSP(Rn), imm7)
    image = format(" 0 1 1 0 1 0 0 1 0 1 %7b %s %s %s", imm7, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDR_immediate_postindex(sf:u1, imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldr %s, [%s], #%d", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("1 %1b 1 1 1 0 0 0 0 1 0 %9b 0 1 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }
op LDR_immediate_preindex(sf:u1, imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldr %s, [%s, #%d]!", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("1 %1b 1 1 1 0 0 0 0 1 0 %9b 1 1 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }
op LDR_immediate_unsignedoffset(sf:u1, imm12:u12,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldr %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm12)
    image = format("1 %1b 1 1 1 0 0 1 0 1 %12b %s %s", sf, imm12, Rn.image, Rt.image)
    action = {
    }

op LDR_literal(sf:u1, imm19:u19, Rt:REG_INDEX)
    syntax = format("ldr %s, %d", get32o64Reg(sf, Rt), imm19)
    image = format("0 %1b 0 1 1 0 0 0 %19b %s", sf, imm19, Rt.image)
    action = {
    }

op LDR_register(sf:u1, Rm:REG_INDEX, option:u3, S:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldr %s, [%s, %s%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), extend(option, S))
    image = format("1 %1b 1 1 1 0 0 0 0 1 1 %s %3b %1b 1 0 %s%s", sf, Rm.image, option, S, Rn.image, Rt.image)
    action = {
    }

op LDRAA(S:u1, imm9:u9, W:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldraa %s, [%s, #%d]%s", get64Reg(Rt), get64RegoSP(Rn), imm9, if W == 1 then "!" else "" endif)
    image = format("1 1 1 1 1 0 0 0 0 %1b 1 %9b %1b 1 %s%s", S, imm9, W, Rn.image, Rt.image)
    action = {
    }

op LDRAB(S:u1, imm9:u9, W:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldrab %s, [%s, #%d]%s", get64Reg(Rt), get64RegoSP(Rn), imm9, if W == 1 then "!" else "" endif)
    image = format("1 1 1 1 1 0 0 0 1 %1b 1 %9b %1b 1%s%s", S, imm9, W, Rn.image, Rt.image)
    action = {
    }

op LDRB_immediate_postindex(imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrb %s, [%s], #%d", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 0 1 0 %9b 0 1 %s %s", imm9, Rn.image, Rt.image)
    action = {
    }
op LDRB_immediate_preindex(imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrb %s, [%s, #%d]!", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 0 1 0 %9b 1 1 %s %s", imm9, Rn.image, Rt.image)
    action = {
    }
op LDRB_immediate_unsignedoffset(imm12:u12,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrb %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm12)
    image = format("0 0 1 1 1 0 0 1 0 1 %12b %s %s", imm12, Rn.image, Rt.image)
    action = {
    }

op LDRB_register(Rm:REG_INDEX, option:u3, S:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = if option == 3 then
                format("ldrb %s, [%s, %s, LSL %d]", get32Reg(Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), S)
            else 
                format("ldrb %s, [%s, %s%s]", get32Reg(Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), extend(option, S))
            endif
    image = format("0 0 1 1 1 0 0 0 0 1 1 %s %3b %1b 1 0 %s%s", Rm.image, option, S, Rn.image, Rt.image)
    action = {
    }

op LDRH_immediate_postindex(imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrh %s, [%s], #%d", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 0 1 0 %9b 0 1 %s %s", imm9, Rn.image, Rt.image)
    action = {
    }
op LDRH_immediate_preindex(imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrh %s, [%s, #%d]!", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 0 1 0 %9b 1 1 %s %s", imm9, Rn.image, Rt.image)
    action = {
    }
op LDRH_immediate_unsignedoffset(imm12:u12,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrh %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm12)
    image = format("0 1 1 1 1 0 0 1 0 1 %12b %s %s", imm12, Rn.image, Rt.image)
    action = {
    }

op LDRH_register(Rm:REG_INDEX, option:u3, S:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldrh %s, [%s, %s%s]", get32Reg(Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), extend(option, S))
    image = format("0 1 1 1 1 0 0 0 0 1 1 %s %3b %1b 1 0 %s%s", Rm.image, option, S, Rn.image, Rt.image)
    action = {
    }

op LDRSB_immediate_postindex(sf:u1, imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsb %s, [%s], #%d", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 1 %1b 0 %9b 0 1 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }
op LDRSB_immediate_preindex(sf:u1, imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsb %s, [%s, #%d]!", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 1 %1b 0 %9b 1 1 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }
op LDRSB_immediate_unsignedoffset(sf:u1, imm12:u12,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsb %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm12)
    image = format("0 0 1 1 1 0 0 1 1 %1b %12b %s %s", sf, imm12, Rn.image, Rt.image)
    action = {
    }

op LDRSB_register(sf:u1, Rm:REG_INDEX, option:u3, S:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = if option == 3 then
                format("ldrsb %s, [%s, %s, LSL %d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), S)
            else 
                format("ldsb %s, [%s, %s%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), extend(option, S))
            endif
    image = format("0 0 1 1 1 0 0 0 1 %1b 1 %s %3b %1b 1 0 %s%s", sf, Rm.image, option, S, Rn.image, Rt.image)
    action = {
    }

op LDRSH_immediate_postindex(sf:u1, imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsh %s, [%s], #%d", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 1 %1b 0 %9b 0 1 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }
op LDRSH_immediate_preindex(sf:u1, imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsh %s, [%s, #%d]!", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 1 %1b 0 %9b 1 1 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }
op LDRSH_immediate_unsignedoffset(sf:u1, imm12:u12,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsh %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm12)
    image = format("0 1 1 1 1 0 0 1 1 %1b %12b %s %s", sf, imm12, Rn.image, Rt.image)
    action = {
    }

op LDRSH_register(sf:u1, Rm:REG_INDEX, option:u3, S:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldrsh %s, [%s, %s%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), extend(option, S))
    image = format("0 1 1 1 1 0 0 0 1 %1b 1 %s %3b %1b 1 0 %s%s", sf, Rm.image, option, S, Rn.image, Rt.image)
    action = {
    }

op LDRSW_immediate_postindex(imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsw %s, [%s], #%d", get64Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("1 0 1 1 1 0 0 0 1 0 0 %9b 0 1 %s %s", imm9, Rn.image, Rt.image)
    action = {
    }
op LDRSW_immediate_preindex(imm9:s9,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsw %s, [%s, #%d]!", get64Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("1 0 1 1 1 0 0 0 1 0 0 %9b 1 1 %s %s", imm9, Rn.image, Rt.image)
    action = {
    }
op LDRSW_immediate_unsignedoffset(imm12:u12,Rn:REG_INDEX,Rt:REG_INDEX)
    syntax = format("ldrsw %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm12)
    image = format("1 0 1 1 1 0 0 1 1 0 %12b %s %s", imm12, Rn.image, Rt.image)
    action = {
    }

op LDRSW_literal(imm19:u19, Rt:REG_INDEX)
    syntax = format("ldrsw %s, %d", get64Reg(Rt), imm19)
    image = format("1 0 0 1 1 0 0 0 %19b %s", imm19, Rt.image)
    action = {
    }

op LDRSW_register(Rm:REG_INDEX, option:u3, S:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldrsw %s, [%s, %s%s]", get32Reg(Rt), get64RegoSP(Rn), get32o64Reg(option<0..0>, Rm), extend(option, S))
    image = format("1 0 1 1 1 0 0 0 1 0 1 %s %3b %1b 1 0 %s%s", Rm.image, option, S, Rn.image, Rt.image)
    action = {
    }


op LDTR(sf:u1, imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldtr %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("1 %1b 1 1 1 0 0 0 0 1 0 %9b 1 0 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDTRB(imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldtrb %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 0 1 0 %9b 1 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDTRH(imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldtrh %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 0 1 0 %9b 1 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDTRSB(sf:u1, imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldtrsb %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 1 %1b 0 %9b 1 0 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDTRSH(sf:u1, imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldtrsh %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 1 %1b 0 %9b 1 0 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDTRSW(imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldtsw %s, [%s, #%d]", get64Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("1 0 1 1 1 0 0 0 1 0 0 %9b 1 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDUR(sf:u1, imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldur %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("1 %1b 1 1 1 0 0 0 0 1 0 %9b 0 0 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDURB(imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldurb %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 0 1 0 %9b 0 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDURH(imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldurh %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 0 1 0 %9b 0 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDURSB(sf:u1, imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldursb %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 1 1 1 0 0 0 1 %1b 0 %9b 0 0 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDURSH(sf:u1, imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldursh %s, [%s, #%d]", get32o64Reg(sf, Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 1 1 1 0 0 0 1 %1b 0 %9b 0 0 %s %s", sf, imm9, Rn.image, Rt.image)
    action = {
    }


op LDURSW(imm9:s9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldusw %s, [%s, #%d]", get64Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("1 0 1 1 1 0 0 0 1 0 0 %9b 0 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDXP(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX, Rt2:REG_INDEX)
    syntax = format("ldxp %s, %s, [%s]", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 0 1 1 1 1 1 1 1 0 %s %s %s", sf,  Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDXR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldxr %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 0 1 0 1 1 1 1 1 0 1 1 1 1 1%s %s", sf, Rn.image, Rt.image)
    action = {
    }

op LDXRB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldxrb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 0 0 1 0 0 0 0 1 0 1 1 1 1 1 0 1 1 1 1 1 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDXRH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldxrh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 0 0 1 0 0 0 0 1 0 11 1 1 1 0 1 111 1 %s%s", Rn.image, Rt.image)
    action = {
    }

//---------------------------------------------------------------------------------------------

op loads_atomic = LDSETB | LDSETH | LDSET | LDSMAXB | LDSMAXH | LDSMAX | LDSMINB | LDSMINH | LDSMIN | LDUMAXB | LDUMAXH | LDUMAX | LDUMINB | LDUMINH | LDUMIN

macro getLDSETBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsetab" \
    else if A == 1 && R == 1 then \
        "ldsetalb" \
    else if A == 0 && R == 0 then \
        "ldsetb" \
    else if A == 0 && R == 1 then \
        "ldsetlb" \
    else "undefined ldsetb??" \
    endif endif endif endif

op LDSETB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSETBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSETHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsetah" \
    else if A == 1 && R == 1 then \
        "ldsetalh" \
    else if A == 0 && R == 0 then \
        "ldseth" \
    else if A == 0 && R == 1 then \
        "ldsetlh" \
    else "undefined ldseth??" \
    endif endif endif endif

op LDSETH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSETHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSETVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsetah" \
    else if A == 1 && R == 1 then \
        "ldsetalh" \
    else if A == 0 && R == 0 then \
        "ldseth" \
    else if A == 0 && R == 1 then \
        "ldsetlh" \
    else "undefined ldset??" \
    endif endif endif endif

op LDSET(sf:u1,A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSETVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf,Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 1 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSMAXBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsmaxab" \
    else if A == 1 && R == 1 then \
        "ldsmaxalb" \
    else if A == 0 && R == 0 then \
        "ldsmaxb" \
    else if A == 0 && R == 1 then \
        "ldsmaxalb" \
    else "undefined ldsmaxb??" \
    endif endif endif endif

op LDSMAXB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSMAXBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 1 0 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSMAXHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsmaxah" \
    else if A == 1 && R == 1 then \
        "ldsmaxalh" \
    else if A == 0 && R == 0 then \
        "ldsmaxh" \
    else if A == 0 && R == 1 then \
        "ldsmaxalh" \
    else "undefined ldsmaxh??" \
    endif endif endif endif

op LDSMAXH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSMAXHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 1 0 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSMAXVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsmaxa" \
    else if A == 1 && R == 1 then \
        "ldsmaxal" \
    else if A == 0 && R == 0 then \
        "ldsmax" \
    else if A == 0 && R == 1 then \
        "ldsmaxl" \
    else "undefined ldsmax??" \
    endif endif endif endif

op LDSMAX(sf:u1,A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSMAXVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf,Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 1 0 0 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSMINBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsminab" \
    else if A == 1 && R == 1 then \
        "ldsminalb" \
    else if A == 0 && R == 0 then \
        "ldsminb" \
    else if A == 0 && R == 1 then \
        "ldsminalb" \
    else "undefined ldsminb??" \
    endif endif endif endif

op LDSMINB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSMINBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 1 0 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSMINHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsminah" \
    else if A == 1 && R == 1 then \
        "ldsminalh" \
    else if A == 0 && R == 0 then \
        "ldsminh" \
    else if A == 0 && R == 1 then \
        "ldsminalh" \
    else "undefined ldsminh??" \
    endif endif endif endif

op LDSMINH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSMINHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 1 0 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDSMINVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldsmina" \
    else if A == 1 && R == 1 then \
        "ldsminal" \
    else if A == 0 && R == 0 then \
        "ldsmin" \
    else if A == 0 && R == 1 then \
        "ldsminl" \
    else "undefined ldsmin??" \
    endif endif endif endif

op LDSMIN(sf:u1,A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDSMINVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf,Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 1 0 1 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }


macro getLDUMAXBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldumaxab" \
    else if A == 1 && R == 1 then \
        "ldumaxalb" \
    else if A == 0 && R == 0 then \
        "ldumaxb" \
    else if A == 0 && R == 1 then \
        "ldumaxalb" \
    else "undefined ldumaxb??" \
    endif endif endif endif

op LDUMAXB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDUMAXBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 1 1 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDUMAXHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldumaxah" \
    else if A == 1 && R == 1 then \
        "ldumaxalh" \
    else if A == 0 && R == 0 then \
        "ldumaxh" \
    else if A == 0 && R == 1 then \
        "ldumaxalh" \
    else "undefined ldumaxh??" \
    endif endif endif endif

op LDUMAXH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDUMAXHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 1 1 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDUMAXVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldumaxa" \
    else if A == 1 && R == 1 then \
        "ldumaxal" \
    else if A == 0 && R == 0 then \
        "ldumax" \
    else if A == 0 && R == 1 then \
        "ldumaxl" \
    else "undefined ldumax??" \
    endif endif endif endif

op LDUMAX(sf:u1,A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDUMAXVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf,Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 1 1 0 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDUMINBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "lduminab" \
    else if A == 1 && R == 1 then \
        "lduminalb" \
    else if A == 0 && R == 0 then \
        "lduminb" \
    else if A == 0 && R == 1 then \
        "lduminalb" \
    else "undefined lduminb??" \
    endif endif endif endif

op LDUMINB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDUMINBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 1 1 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDUMINHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "lduminah" \
    else if A == 1 && R == 1 then \
        "lduminalh" \
    else if A == 0 && R == 0 then \
        "lduminh" \
    else if A == 0 && R == 1 then \
        "lduminalh" \
    else "undefined lduminh??" \
    endif endif endif endif

op LDUMINH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDUMINHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 1 1 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDUMINVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldumina" \
    else if A == 1 && R == 1 then \
        "lduminal" \
    else if A == 0 && R == 0 then \
        "ldumin" \
    else if A == 0 && R == 1 then \
        "lduminl" \
    else "undefined ldumin??" \
    endif endif endif endif

op LDUMIN(sf:u1,A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDUMINVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf,Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 1 1 1 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }










































































