op memory = CPYFP | CPYFPN | CPYFPRN | CPYFPRT | CPYFPRTN | CPYFPRTRN | CPYFPRTWN |
    CPYFPT | CPYFPTN | CPYFPTRN | CPYFPTWN | CPYFPWN | CPYFPWT | CPYFPWTN | CPYFPWTRN | CPYFPWTWN |
    CPYP | CPYPN | CPYPRN | CPYPRT | CPYPRTN | CPYPRTRN | CPYPRTWN | 
    CPYPT | CPYPTN | CPYPTRN | CPYPTWN | CPYPWN | CPYPWT | CPYPWTRN | CPYPWTWN |
    CSDB | DGH | DMB | DSB | loads

macro getCPYFPVariant(op1) = \
    if op1 == 2 then \
        "cpyfe" \
    else if op1 == 1 then \
            "cpyfm" \
        else if op1 == 0 then \
                "cpyfp" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFP(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b0 1 1 0 0 1%2b0%s0 0 0 0 0 1%s%s", sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
        // if !HaveFeatMOPS() then UNDEFINED;
        // if sz != '00' then UNDEFINED;
        // integer d = UInt(Rd);
        // integer s = UInt(Rs);
        // integer n = UInt(Rn);
        // bits(4) options = op2;
        // MOPSStage stage;
        // case op1 of
        // when '00' stage = MOPSStage_Prologue;
        // when '01' stage = MOPSStage_Main;
        // when '10' stage = MOPSStage_Epilogue;
        // otherwise SEE "Memory Copy and Memory Set";
        // CheckMOPSEnabled();
        // if s == n || s == d || n == d || d == 31 || s == 31 || n == 31 then
        // c = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        // assert c IN {Constraint_UNDEF, Constraint_NOP};
        // case c of
        // when Constraint_UNDEF UNDEFINED;
        // when Constraint_NOP
        // EndOfInstruction();
        // integer N = MaxBlockSizeCopiedBytes();
        // bits(64) toaddress = X[d, 64];
        // bits(64) fromaddress = X[s, 64];
        // bits(64) cpysize = X[n, 64];
        // bits(4) nzcv = PSTATE.<N,Z,C,V>;
        // bits(64) stagecpysize;
        // bits(8*N) readdata;
        // integer B;
        // boolean supports_option_a = CPYFOptionA();
        // boolean rprivileged;
        // boolean wprivileged;
        // case PSTATE.EL of
        // when EL0
        // rprivileged = FALSE;
        // wprivileged = FALSE;
        // when EL1
        // if EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11' then
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // else
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // when EL2
        // if HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11' then
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // else
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // when EL3
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // if HaveUAOExt() && PSTATE.UAO == '1' then
        // rprivileged = PSTATE.EL != EL0;
        // wprivileged = PSTATE.EL != EL0;
        // boolean rnontemporal = options<3> == '1';
        // boolean wnontemporal = options<2> == '1';
        // AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
        // AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
        // if stage == MOPSStage_Prologue then
        // if cpysize<63> == '1' then cpysize = 0x7FFFFFFFFFFFFFFF<63:0>;
        // if supports_option_a then
        // nzcv = '0000';
        // // Copy in the forward direction offsets the arguments.
        // toaddress = toaddress + cpysize;
        // fromaddress = fromaddress + cpysize;
        // cpysize = Zeros(64) - cpysize;
        // else
        // nzcv = '0010';
        // // IMP DEF selection of the amount covered by pre-processing.
        // stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        // assert stagecpysize<63> == cpysize<63> || stagecpysize == Zeros(64);
        // if SInt(cpysize) > 0 then
        // assert SInt(stagecpysize) <= SInt(cpysize);
        // else
        // assert SInt(stagecpysize) >= SInt(cpysize);
        // else
        // boolean zero_size_exceptions = MemCpyZeroSizeCheck();
        // // Check if this version is consistent with the state of the call.
        // if zero_size_exceptions || SInt(cpysize) != 0 then
        // if supports_option_a then
        // if nzcv<1> == '1' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,options);
        // else
        // if nzcv<1> == '0' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,
        // options);
        // bits(64) postsize = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        // assert postsize<63> == cpysize<63> || SInt(postsize) == 0;
        // if stage == MOPSStage_Main then
        // stagecpysize = cpysize - postsize;
        // // Check if the parameters to this instruction are valid.
        // if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = FALSE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // else
        // stagecpysize = postsize;
        // // Check if the parameters to this instruction are valid for the epilogue.
        // if (cpysize != postsize || MemCpyParametersIllformedE(toaddress, fromaddress, cpysize)) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = TRUE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // if supports_option_a then
        // while SInt(stagecpysize) != 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= -1 * SInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress+cpysize, B, raccdesc];
        // Mem[toaddress+cpysize, B, waccdesc] = readdata<B*8-1:0>;
        // cpysize = cpysize + B;
        // stagecpysize = stagecpysize + B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // else
        // while UInt(stagecpysize) > 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= UInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress, B, raccdesc];
        // Mem[toaddress, B, waccdesc] = readdata<B*8-1:0>;
        // fromaddress = fromaddress + B;
        // toaddress = toaddress + B;
        // cpysize = cpysize - B;
        // stagecpysize = stagecpysize - B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // if stage == MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // PSTATE.<N,Z,C,V> = nzcv;
    }

macro getCPYFPNVariant(op1) = \
    if op1 == 2 then \
        "cpyfen" \
    else if op1 == 1 then \
            "cpyfmn" \
        else if op1 == 0 then \
                "cpyfpn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!,[%s]!,%s!", getCPYFPNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b0 1 1 0 0 1%2b0%s1 1 0 0 0 1%s%s", sz, op1, Rs.image, Rn.image, Rd.image)
    action = {
        // if !HaveFeatMOPS() then UNDEFINED;
        // if sz != '00' then UNDEFINED;
        // integer d = UInt(Rd);
        // integer s = UInt(Rs);
        // integer n = UInt(Rn);
        // bits(4) options = op2;
        // MOPSStage stage;
        // case op1 of
        // when '00' stage = MOPSStage_Prologue;
        // when '01' stage = MOPSStage_Main;
        // when '10' stage = MOPSStage_Epilogue;
        // otherwise SEE "Memory Copy and Memory Set";
        // CheckMOPSEnabled();
        // if s == n || s == d || n == d || d == 31 || s == 31 || n == 31 then
        // c = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        // assert c IN {Constraint_UNDEF, Constraint_NOP};
        // case c of
        // when Constraint_UNDEF UNDEFINED;
        // when Constraint_NOP
        // EndOfInstruction();
        // integer N = MaxBlockSizeCopiedBytes();
        // bits(64) toaddress = X[d, 64];
        // bits(64) fromaddress = X[s, 64];
        // bits(64) cpysize = X[n, 64];
        // bits(4) nzcv = PSTATE.<N,Z,C,V>;
        // bits(64) stagecpysize;

        // bits(8*N) readdata;
        // integer B;
        // boolean supports_option_a = CPYFOptionA();
        // boolean rprivileged;
        // boolean wprivileged;
        // case PSTATE.EL of
        // when EL0
        // rprivileged = FALSE;
        // wprivileged = FALSE;
        // when EL1
        // if EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11' then
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // else
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // when EL2
        // if HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11' then
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // else
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // when EL3
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // if HaveUAOExt() && PSTATE.UAO == '1' then
        // rprivileged = PSTATE.EL != EL0;
        // wprivileged = PSTATE.EL != EL0;
        // boolean rnontemporal = options<3> == '1';
        // boolean wnontemporal = options<2> == '1';
        // AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
        // AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
        // if stage == MOPSStage_Prologue then
        // if cpysize<63> == '1' then cpysize = 0x7FFFFFFFFFFFFFFF<63:0>;
        // if supports_option_a then
        // nzcv = '0000';
        // // Copy in the forward direction offsets the arguments.
        // toaddress = toaddress + cpysize;
        // fromaddress = fromaddress + cpysize;
        // cpysize = Zeros(64) - cpysize;
        // else
        // nzcv = '0010';
        // // IMP DEF selection of the amount covered by pre-processing.
        // stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        // assert stagecpysize<63> == cpysize<63> || stagecpysize == Zeros(64);
        // if SInt(cpysize) > 0 then
        // assert SInt(stagecpysize) <= SInt(cpysize);
        // else
        // assert SInt(stagecpysize) >= SInt(cpysize);
        // else
        // boolean zero_size_exceptions = MemCpyZeroSizeCheck();
        // // Check if this version is consistent with the state of the call.
        // if zero_size_exceptions || SInt(cpysize) != 0 then
        // if supports_option_a then
        // if nzcv<1> == '1' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,options);
        // else
        // if nzcv<1> == '0' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,
        // options);
        // bits(64) postsize = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        // assert postsize<63> == cpysize<63> || SInt(postsize) == 0;
        // if stage == MOPSStage_Main then
        // stagecpysize = cpysize - postsize;
        // // Check if the parameters to this instruction are valid.
        // if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = FALSE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // else
        // stagecpysize = postsize;
        // // Check if the parameters to this instruction are valid for the epilogue.
        // if (cpysize != postsize || MemCpyParametersIllformedE(toaddress, fromaddress, cpysize)) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = TRUE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // if supports_option_a then
        // while SInt(stagecpysize) != 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= -1 * SInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress+cpysize, B, raccdesc];
        // Mem[toaddress+cpysize, B, waccdesc] = readdata<B*8-1:0>;
        // cpysize = cpysize + B;
        // stagecpysize = stagecpysize + B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // else
        // while UInt(stagecpysize) > 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= UInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress, B, raccdesc];
        // Mem[toaddress, B, waccdesc] = readdata<B*8-1:0>;
        // fromaddress = fromaddress + B;
        // toaddress = toaddress + B;
        // cpysize = cpysize - B;
        // stagecpysize = stagecpysize - B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // if stage == MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // PSTATE.<N,Z,C,V> = nzcv;
    }

macro getCPYFPRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfern" \
    else if op1 == 1 then \
            "cpyfmrn" \
        else if op1 == 0 then \
                "cpyfprn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b0 1 1 0 0 1%2b 0 %s 1 0 0 0 0 1 %s%s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
        // if !HaveFeatMOPS() then UNDEFINED;
        // if sz != '00' then UNDEFINED;
        // integer d = UInt(Rd);
        // integer s = UInt(Rs);
        // integer n = UInt(Rn);
        // bits(4) options = op2;
        // MOPSStage stage;
        // case op1 of
        // when '00' stage = MOPSStage_Prologue;
        // when '01' stage = MOPSStage_Main;
        // when '10' stage = MOPSStage_Epilogue;
        // otherwise SEE "Memory Copy and Memory Set";
        // CheckMOPSEnabled();
        // if s == n || s == d || n == d || d == 31 || s == 31 || n == 31 then
        // c = ConstrainUnpredictable(Unpredictable_MOPSOVERLAP31);
        // assert c IN {Constraint_UNDEF, Constraint_NOP};
        // case c of
        // when Constraint_UNDEF UNDEFINED;
        // when Constraint_NOP
        // EndOfInstruction();
        // integer N = MaxBlockSizeCopiedBytes();
        // bits(64) toaddress = X[d, 64];
        // bits(64) fromaddress = X[s, 64];
        // bits(64) cpysize = X[n, 64];
        // bits(4) nzcv = PSTATE.<N,Z,C,V>;
        // bits(64) stagecpysize;

        // bits(8*N) readdata;
        // integer B;
        // boolean supports_option_a = CPYFOptionA();
        // boolean rprivileged;
        // boolean wprivileged;
        // case PSTATE.EL of
        // when EL0
        // rprivileged = FALSE;
        // wprivileged = FALSE;
        // when EL1
        // if EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11' then
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // else
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // when EL2
        // if HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11' then
        // rprivileged = options<1> == '0';
        // wprivileged = options<0> == '0';
        // else
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // when EL3
        // rprivileged = TRUE;
        // wprivileged = TRUE;
        // if HaveUAOExt() && PSTATE.UAO == '1' then
        // rprivileged = PSTATE.EL != EL0;
        // wprivileged = PSTATE.EL != EL0;
        // boolean rnontemporal = options<3> == '1';
        // boolean wnontemporal = options<2> == '1';
        // AccessDescriptor raccdesc = CreateAccDescMOPS(MemOp_LOAD, rprivileged, rnontemporal);
        // AccessDescriptor waccdesc = CreateAccDescMOPS(MemOp_STORE, wprivileged, wnontemporal);
        // if stage == MOPSStage_Prologue then
        // if cpysize<63> == '1' then cpysize = 0x7FFFFFFFFFFFFFFF<63:0>;
        // if supports_option_a then
        // nzcv = '0000';
        // // Copy in the forward direction offsets the arguments.
        // toaddress = toaddress + cpysize;
        // fromaddress = fromaddress + cpysize;
        // cpysize = Zeros(64) - cpysize;
        // else
        // nzcv = '0010';
        // // IMP DEF selection of the amount covered by pre-processing.
        // stagecpysize = CPYPreSizeChoice(toaddress, fromaddress, cpysize);
        // assert stagecpysize<63> == cpysize<63> || stagecpysize == Zeros(64);
        // if SInt(cpysize) > 0 then
        // assert SInt(stagecpysize) <= SInt(cpysize);
        // else
        // assert SInt(stagecpysize) >= SInt(cpysize);
        // else
        // boolean zero_size_exceptions = MemCpyZeroSizeCheck();
        // // Check if this version is consistent with the state of the call.
        // if zero_size_exceptions || SInt(cpysize) != 0 then
        // if supports_option_a then
        // if nzcv<1> == '1' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,options);
        // else
        // if nzcv<1> == '0' then // PSTATE.C
        // boolean wrong_option = TRUE;
        // boolean from_epilogue = stage == MOPSStage_Epilogue;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue,
        // options);
        // bits(64) postsize = CPYPostSizeChoice(toaddress, fromaddress, cpysize);
        // assert postsize<63> == cpysize<63> || SInt(postsize) == 0;
        // if stage == MOPSStage_Main then
        // stagecpysize = cpysize - postsize;
        // // Check if the parameters to this instruction are valid.
        // if MemCpyParametersIllformedM(toaddress, fromaddress, cpysize) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = FALSE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // else
        // stagecpysize = postsize;
        // // Check if the parameters to this instruction are valid for the epilogue.
        // if (cpysize != postsize || MemCpyParametersIllformedE(toaddress, fromaddress, cpysize)) then
        // boolean wrong_option = FALSE;
        // boolean from_epilogue = TRUE;
        // MismatchedMemCpyException(supports_option_a, d, s, n, wrong_option, from_epilogue, options);
        // if supports_option_a then
        // while SInt(stagecpysize) != 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= -1 * SInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress+cpysize, B, raccdesc];
        // Mem[toaddress+cpysize, B, waccdesc] = readdata<B*8-1:0>;
        // cpysize = cpysize + B;
        // stagecpysize = stagecpysize + B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // else
        // while UInt(stagecpysize) > 0 do
        // // IMP DEF selection of the block size that is worked on. While many
        // // implementations might make this constant, that is not assumed.
        // B = CPYSizeChoice(toaddress, fromaddress, cpysize);
        // assert B <= UInt(stagecpysize);
        // readdata<B*8-1:0> = Mem[fromaddress, B, raccdesc];
        // Mem[toaddress, B, waccdesc] = readdata<B*8-1:0>;
        // fromaddress = fromaddress + B;
        // toaddress = toaddress + B;
        // cpysize = cpysize - B;
        // stagecpysize = stagecpysize - B;
        // if stage != MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // if stage == MOPSStage_Prologue then
        // X[n, 64] = cpysize;
        // X[d, 64] = toaddress;
        // X[s, 64] = fromaddress;
        // PSTATE.<N,Z,C,V> = nzcv;
    }

macro getCPYFPRTVariant(op1) = \
    if op1 == 2 then \
        "cpyfert" \
    else if op1 == 1 then \
            "cpyfmrt" \
        else if op1 == 0 then \
                "cpyfprt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPRTNVariant(op1) = \
    if op1 == 2 then \
        "cpyfertn" \
    else if op1 == 1 then \
            "cpyfmrtn" \
        else if op1 == 0 then \
                "cpyfprtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPRTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfertrn" \
    else if op1 == 1 then \
            "cpyfmrtrn" \
        else if op1 == 0 then \
                "cpyfprtrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPRTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfertwn" \
    else if op1 == 1 then \
            "cpyfmrtwn" \
        else if op1 == 0 then \
                "cpyfprtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPRTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPRTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTVariant(op1) = \
    if op1 == 2 then \
        "cpyfet" \
    else if op1 == 1 then \
            "cpyfmt" \
        else if op1 == 0 then \
                "cpyfpt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTNVariant(op1) = \
    if op1 == 2 then \
        "cpyfetn" \
    else if op1 == 1 then \
            "cpyfmtn" \
        else if op1 == 0 then \
                "cpyfptn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfetrn" \
    else if op1 == 1 then \
            "cpyfmtrn" \
        else if op1 == 0 then \
                "cpyfptrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfetwn" \
    else if op1 == 1 then \
            "cpyfmtwn" \
        else if op1 == 0 then \
                "cpyfptwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewn" \
    else if op1 == 1 then \
            "cpyfmwn" \
        else if op1 == 0 then \
                "cpyfpwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTVariant(op1) = \
    if op1 == 2 then \
        "cpyfewt" \
    else if op1 == 1 then \
            "cpyfmwt" \
        else if op1 == 0 then \
                "cpyfpwt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 0 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewtn" \
    else if op1 == 1 then \
            "cpyfmwtn" \
        else if op1 == 0 then \
                "cpyfpwtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewtn" \
    else if op1 == 1 then \
            "cpyfmwtn" \
        else if op1 == 0 then \
                "cpyfpwtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 1 0 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYFPWTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyfewtwn" \
    else if op1 == 1 then \
            "cpyfmwtwn" \
        else if op1 == 0 then \
                "cpyfpwtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYFPWTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYFPWTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 0 0 1 %2b 0 %s 0 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPVariant(op1) = \
    if op1 == 2 then \
        "cpye" \
    else if op1 == 1 then \
            "cpym" \
        else if op1 == 0 then \
                "cpyp" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYP(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPNVariant(op1) = \
    if op1 == 2 then \
        "cpyen" \
    else if op1 == 1 then \
            "cpymn" \
        else if op1 == 0 then \
                "cpypn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRNVariant(op1) = \
    if op1 == 2 then \
        "cpyern" \
    else if op1 == 1 then \
            "cpymrn" \
        else if op1 == 0 then \
                "cpyprn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 0 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTVariant(op1) = \
    if op1 == 2 then \
        "cpyert" \
    else if op1 == 1 then \
            "cpymrt" \
        else if op1 == 0 then \
                "cpyprt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTNVariant(op1) = \
    if op1 == 2 then \
        "cpyertn" \
    else if op1 == 1 then \
            "cpymrtn" \
        else if op1 == 0 then \
                "cpyprtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyertrn" \
    else if op1 == 1 then \
            "cpymrtrn" \
        else if op1 == 0 then \
                "cpyprtrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 0 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPRTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyertwn" \
    else if op1 == 1 then \
            "cpymrtwn" \
        else if op1 == 0 then \
                "cpyprtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPRTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPRTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 1 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTVariant(op1) = \
    if op1 == 2 then \
        "cpyet" \
    else if op1 == 1 then \
            "cpymt" \
        else if op1 == 0 then \
                "cpypt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTNVariant(op1) = \
    if op1 == 2 then \
        "cpyetn" \
    else if op1 == 1 then \
            "cpymtn" \
        else if op1 == 0 then \
                "cpyptn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyetrn" \
    else if op1 == 1 then \
            "cpymtrn" \
        else if op1 == 0 then \
                "cpyptrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 0 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyetwn" \
    else if op1 == 1 then \
            "cpymtwn" \
        else if op1 == 0 then \
                "cpyptwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 1 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWNVariant(op1) = \
    if op1 == 2 then \
        "cpyewn" \
    else if op1 == 1 then \
            "cpymwn" \
        else if op1 == 0 then \
                "cpypwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 0 0 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTVariant(op1) = \
    if op1 == 2 then \
        "cpyewt" \
    else if op1 == 1 then \
            "cpymwt" \
        else if op1 == 0 then \
                "cpypwt" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWT(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 0 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTNVariant(op1) = \
    if op1 == 2 then \
        "cpyewtn" \
    else if op1 == 1 then \
            "cpymwtn" \
        else if op1 == 0 then \
                "cpypwtn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWTN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTRNVariant(op1) = \
    if op1 == 2 then \
        "cpyewtrn" \
    else if op1 == 1 then \
            "cpymwtrn" \
        else if op1 == 0 then \
                "cpypwtrn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWTRN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTRNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 1 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

macro getCPYPWTWNVariant(op1) = \
    if op1 == 2 then \
        "cpyewtwn" \
    else if op1 == 1 then \
            "cpymwtwn" \
        else if op1 == 0 then \
                "cpypwtwn" \
            else \
                "undefined cpy??" \
            endif \
        endif \
    endif

op CPYPWTWN(sz:u2, op1:u2,Rs:REG_INDEX,Rn:REG_INDEX,Rd:REG_INDEX)
    syntax = format("%s [%s]!, [%s]!, %s!", getCPYPWTWNVariant(op1), get64Reg(Rd), get64Reg(Rs), get64Reg(Rn))
    image = format("%2b 0 1 1 1 0 1 %2b 0 %s 0 1 0 1 0 1 %s %s",sz,op1,Rs.image,Rn.image,Rd.image)
    action = {
    }

op CSDB()
    syntax = "csdb"
    image = "1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 1 0 0 1 1 1 1 1"
    action = {
        //ConsumptionOfSpeculativeDataBarrier();
    }

op DGH()
    syntax = "dgh"
    image = "1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1"
    action = {
    }

op DMB(CRm:u4)
    syntax = format("dmb  #%d", CRm)
    image = format("1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 %4b 1 0 1 1 1 1 1 1", CRm)
    action = {
    }

op DSB(CRm:u4)
    syntax = format("dsb  #%d", CRm)
    image = format("1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 %4b 1 0 0 1 1 1 1 1", CRm)
    action = {
    }

op ISB(CRm:u4)
    syntax = format("isb  #%d", CRm)
    image = format("1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 %4b 1 1 0 1 1 1 1 1", CRm)
    action = {
    }

op loads = LD64B | LDADDB | LDADDH | LDADD | LDAPR | LDAPRB | LDAPRH | LDAPUR | LDAPURB | LDAPURH | LDAPURSB | LDAPURSH | LDAPURSW |
    LDAR | LDARB | LDARH | LDAXP | LDAXR | LDAXRB | LDAXRH | LDCLRB | LDCLRH | LDCLR | LDEORB | LDEORH | LDEOR

op LD64B(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ld64b %s, [%s]", get64Reg(Rt), get64RegoSP(Rn))
    image = format("1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 0 %s%s", Rn.image, Rt.image)
    action = {
    }

macro getLDADDBVariante(A,R) = \
    if A == 1 && R == 0 then \
        "ldaddab" \
    else if A == 1 && R == 1 then \
        "ldaddalb" \
    else if A == 0 && R == 0 then \
        "ldaddb" \
    else if A == 0 && R == 1 then \
        "ldaddlb" \
    else "undefined lda??" \
    endif \
    endif \
    endif \
    endif

op LDADDB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDADDBVariante(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 0 0 0 %s%s", A,R,Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDADDHVariante(A,R) = \
    if A == 1 && R == 0 then \
        "ldaddah" \
    else if A == 1 && R == 1 then \
        "ldaddalh" \
    else if A == 0 && R == 0 then \
        "ldaddhh" \
    else if A == 0 && R == 1 then \
        "ldaddlh" \
    else "undefined lda??" \
    endif \
    endif \
    endif \
    endif

op LDADDH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDADDHVariante(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 0 0 0 %s%s", A,R,Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDADDVariante(A,R) = \
    if A == 0 && R == 0 then \
        "ldadd" \
    else if A == 1 && R == 0 then \
        "ldadda" \
    else if A == 1 && R == 1 then \
        "ldaddal" \
    else if A == 0 && R == 1 then \
        "ldaddl" \
    else "undefined lda??" \
    endif \
    endif \
    endif \
    endif

op LDADD(sf:u1, A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s, %s, [%s]", getLDADDVariante(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 0 0 0 %s%s", sf, A,R,Rs.image, Rn.image, Rt.image)
    action = {
    }

op LDAPR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapr %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDAPRB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaprb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDAPRH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaprh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 %s%s", Rn.image, Rt.image)
    action = {
    }

op LDAPUR(sf:u1, imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapur %s, [%s, #%d]", get32o64Reg(sf,Rt), get64RegoSP(Rn), imm9)
    image = format("1 %1b 0 1 1 0 0 1 0 1 0 %9b 00 %s%s", sf, imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURB(imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapurb %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 0 1 1 0 0 1 0 1 0 %9b 0 0 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURH(imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapurh %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 0 1 1 0 0 1 0 1 0 %9b 00 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURSB(opc:u1, imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapursb %s, [%s, #%d]", get32o64Reg(opc==0, Rt), get64RegoSP(Rn), imm9)
    image = format("0 0 0 1 1 0 0 1 1 %1b 0 %9b 00 %s%s", opc, imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURSH(opc:u1, imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapursh %s, [%s, #%d]", get32o64Reg(opc==0,Rt), get64RegoSP(Rn), imm9)
    image = format("0 1 0 1 1 0 0 1 1 %1b 0 %9b 00 %s%s", opc, imm9, Rn.image, Rt.image)
    action = {
    }

op LDAPURSW(imm9:u9, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldapursw %s, [%s, #%d]", get32Reg(Rt), get64RegoSP(Rn), imm9)
    image = format("1 0 0 1 1 0 0 1 1 0 0 %9b 00 %s%s", imm9, Rn.image, Rt.image)
    action = {
    }

op LDAR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldar %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 1 1 1 1 1 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDARB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldarb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 11 1 1 1 %s%s", Rn.image, Rt.image)
    action = {
    }


op LDARH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldarh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 11 1 1 1%s%s", Rn.image, Rt.image)
    action = {
    }

op LDAXP(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX, Rt2:REG_INDEX)
    syntax = format("ldaxp %s, %s, [%s]", get32o64Reg(sf, Rt), get32o64Reg(sf, Rt2), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 0 1 11 1 1 1 1 1 %s%s%s", sf, Rt2.image, Rn.image, Rt.image)
    action = {
    }

op LDAXR(sf:u1, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaxr %s, [%s]", get32o64Reg(sf, Rt), get64RegoSP(Rn))
    image = format("1 %1b 0 0 1 0 0 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 %s%s", sf, Rn.image, Rt.image)
    action = {
    }

op LDAXRB(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaxrb %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 0 0 0 1 0 0 0 0 1 0 1 1 11 1 1 1 1 1 1 1%s%s", Rn.image, Rt.image)
    action = {
    }

op LDAXRH(Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("ldaxrh %s, [%s]", get32Reg(Rt), get64RegoSP(Rn))
    image = format("0 1 0 0 1 0 0 0 0 1 0 1 1 11 1 1 1 1 1 1 1%s%s", Rn.image, Rt.image)
    action = {
    }

macro getLDCLRBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldclrab" \
    else if A == 1 && R == 1 then \
        "ldclralb" \
    else if A == 0 && R == 0 then \
        "ldclrb" \
    else if A == 0 && R == 1 then \
        "ldclrlb" \
    else "undefined ldcl??" \
    endif endif endif endif

op LDCLRB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDCLRBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDCLRHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldclrah" \
    else if A == 1 && R == 1 then \
        "ldclralh" \
    else if A == 0 && R == 0 then \
        "ldclrh" \
    else if A == 0 && R == 1 then \
        "ldclrlh" \
    else "undefined ldcl??" \
    endif endif endif endif

op LDCLRH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDCLRHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 1 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDCLRVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldclra" \
    else if A == 1 && R == 1 then \
        "ldclral" \
    else if A == 0 && R == 0 then \
        "ldclr" \
    else if A == 0 && R == 1 then \
        "ldclrl" \
    else "undefined ldcl??" \
    endif endif endif endif

op LDCLR(sf:u1, A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDCLRVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf, Rt), get64RegoSP(Rt))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 0 1 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }


macro getLDEORBVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldeorab" \
    else if A == 1 && R == 1 then \
        "ldeoralb" \
    else if A == 0 && R == 0 then \
        "ldeorb" \
    else if A == 0 && R == 1 then \
        "ldeorlb" \
    else "undefined ldeor??" \
    endif endif endif endif

op LDEORB(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDEORBVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 0 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDEORHVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldeorah" \
    else if A == 1 && R == 1 then \
        "ldeoralh" \
    else if A == 0 && R == 0 then \
        "ldeorh" \
    else if A == 0 && R == 1 then \
        "ldeorlh" \
    else "undefined ldeor??" \
    endif endif endif endif

op LDEORH(A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDEORHVariant(A,R), get32Reg(Rs), get32Reg(Rt), get64RegoSP(Rt))
    image = format("0 1 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 0 0 0 %s%s", A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }

macro getLDEORVariant(A,R) = \
    if A == 1 && R == 0 then \
        "ldeora" \
    else if A == 1 && R == 1 then \
        "ldeoral" \
    else if A == 0 && R == 0 then \
        "ldeor" \
    else if A == 0 && R == 1 then \
        "ldeorl" \
    else "undefined ldeor??" \
    endif endif endif endif

op LDEOR(sf:u1, A:u1, R:u1, Rs:REG_INDEX, Rn:REG_INDEX, Rt:REG_INDEX)
    syntax = format("%s %s,%s,[%s]", getLDEORVariant(A,R), get32o64Reg(sf, Rs), get32o64Reg(sf, Rt), get64RegoSP(Rt))
    image = format("1 %1b 1 1 1 0 0 0 %1b %1b 1 %s 0 0 1 0 0 0 %s%s", sf, A, R, Rs.image, Rn.image, Rt.image)
    action = {
    }






















